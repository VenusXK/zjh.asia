# 数组与字符串

## 一维数组的定义和初始化

### 一维数组的定义

Python 中有 `eval('a'+i)` 的方法可以访问若干个标量，C/C++ 中使用数组。原因是 Python 是基于虚拟机的语言，而 C 和 C++ 是基于内存的语言。



数组可以方便**二次使用**若干个数据。



`int a[n]` 中 `n` 是常量表达式，C++ 标准 11 之后可以使用变量。



定义行和使用行某些符号的意义是不同的，`int a[3]` 中 3 是指数据的个数，而 `a[3] = 0` 中 3 是指第四个元素。

::: info 类比
`&` 符号的使用上也存在这样的现象，`int &x = a;` 中 `&` 表示引用，而 `int x = &a;` 中 `&` 表示地址。
:::

### 一维数组的初始化

**部分初始化**时，未赋值元素为0。非部分初始化时，具体值是不知道的。

```cpp
int a[100] = {1, 2, 3};
// a: 1, 2, 3, 0, 0, 0 ... 0;
int b[100] = {0};
// b: 0, 0, 0 ... 0;
int c[100];
// c: 2931 213 324 21 ... (随机)
```

除部分初始化外，只能单独赋值，不允许整体输入，不允许整体输出。


无论何种定义方式，定义时必须明确到底有多大，因为要分配内存。

定义时可以提供冗余容量，防止数组越界。

```cpp
cin >> n;
int a[n + 5];
```


做 OJ 题时，如果遇到 $10^6$ 左右的数，表示要使用数组，否则可能会遇到困难。

::: info 拓展
$10^6$ $10^5$ 打表法 恰巧建立数组；

$10^7$ $10^8$ 无法建立数组，一定要优化

$300$ 表示三重循环每个最多 300 次；

$5000$ 表示要优化，最多使用二重循环；
:::

### 一维数组的内存模型

数组的建立过程是一次内存分配，其开销相对标量来说很多，能不用就不用，如能用“递归”就不用数组，因为程序相对来说简单些。



`char` 的长度是 1 字节，0 ~ 255 位，无法存储汉字，汉字需要 2 字节。


### 数组作为函数参数

```cpp{1,11}
int argmin(int n, int arr[]){
    for(int i = 0; i < n; i ++){
        // visit a[i]
    }
    return xx;
}

int main(){
    int n; cin >> n;
    int a[n + 10];
    cout << argmin(n, a) << endl;
    return 0;
}
```

`a[n]` 中 `a` 是指针常量，除部分初始化外，只能单独赋值，不允许整体输入，不允许整体输出，比如：

```cpp
int a[3] = {1, 2, 3};
int b[3];
b = a; // 报错，数组不能对数组赋值，同时，b是常量地址，不是变量地址，不能修改
```

正确的代码中，`int arr[]` 形式上是数组，实际是指针变量，只表示 `arr` 是个接受地址的变量，与 `[]` 中的数据毫无关系，可写为 `int arr[50]`、`int arr[500]`、`int arr[n]`，这里的 `50`、`500`、`n` 毫无作用，因此必须把数组长度传递过来。

**训练 1**：求下方代码运行后，`arr` 的内容。

```cpp
int main(){
    int a[] = {1, 2, 3};
    argmin(a+1);
}
void argmin(int arr[]){
    arr[0] = 1;
}
```

上述程序运行后 `arr` 内容为 `{1, 1, 3}`，因为传递的是地址。


**训练 2**：求下方代码运行后，`a` 的内容。

```cpp
int main(){
    int a = 1;
    argmin(&a);
}
void argmin(int arr[]){
    arr[0] = 0;
}
```

上述程序运行后 `a` 的值为0，因为传递的是地址，`int arr[]` 和数组没有本质关联，相当于 `int * arr`，这里比较标准的访问方式是 `*arr = 0`，`arr[0]` 的含义表达的就是 `*(arr+0)`，所以可以正确编译运行。

## 一维数组的应用

### 插入与删除

通过学习本章节，可以进一步理解数组的内存分配。

数组的插入注意点如下，**1)** 倒着赋值，保证数据不被覆盖；**2)** 函数中运行时确保要有足够的空间，可以建立数组时增加几个长度，如 `int a[n+5]`，这种问题导致的错误比较难排查。

### 与循环点联动

此类问题的经验如下，**1)** X重数组对应X重循环；**2)** 能用标量不用数组，能用X维数组不用X+1维数组，二维矩阵的边界值、对角矩阵、上三角矩阵等可以用一维数组存储。


下面的题目使用了打表法，老师给的题解中包含了匿名函数的使用，老师介绍为用CUDA训练时为实现并行化尽量不使用 `if...else...` 循环。

**题目要求**：把1月1日当做第1天，当用户输入年份和第n天时，输出第n天是几月几日？

```cpp
#include<iostream>
using namespace std;
int main(){
    int year, n;
    cin >> year >> n;
    int month[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    auto leapyear = [](int year){return year%400==0||(year%4==0&&year%100==0);};
    month[1]+=leapyear(year);
    int i = 0;
    while(n>month[i])
        n- = month[i++];
    cout << i + 1 << "月" << n << "日" << endl;
    return 0;
}
```

::: warning 匿名函数
先写 `[ ]` 表示下面描述的是函数，在变量名后面用 `[ ]` 表示数组。

```c++
auto leapyear = [](int year){return year%400==0||(year%4==0&&year%100==0);};
```

上述函数使用匿名函数，`leapyear` 是一个函数，使用 `auto` 是因为函数的类型十分复杂，这里用 `auto` 让编译器自动解析

:::

### 尺取法

用两个指针解决区间问题，是一种优化技巧，分为反向扫描法和同向扫描法，解决嵌套循环 $O(n^2)$ 的时间复杂度到 $O(n)$。

#### 1. 对称判断

**题目要求**：给定数组arr，判断数组是否对称。

```cpp
bool sym(int n, int arr[]){
    for(int i = 0, j = n01; i < j; ++i, --j)
        if(arr[i] != arr[j])
            return false;
        return true;
}
```

通过两个游标解决该问题，一定要注意控制循环结束，交换要在数组的中间停止，否则会发生如下情形：

```cpp
i->    <-j
    ij   
j        i
```

在某些问题下，这可能会导致数组被对称修改了两遍，表现出来数组没有变化。

::: warning `for` 的多变量用法

总共只有两个分号，对应循环三要素。

- **循环变量初始化**：逗号分割，可有多个；
- **循环条件判断**：`&&` 和 `||` 分割；
- **控制循环变量**：逗号分割，可有多个；

:::

#### 2. 删除特定值

**题目要求**：给定数组arr，要求删除其指定值val。

此类问题容易导致下标混乱的问题，第一遍删除改变下标，使得第二次删除时下标对应不对导致删掉的错误位。

- **方法一**：两遍循环，每次都从0开始；
- **方法二**：建立新数组，把删除后的数组依次复制过来。

下面的解法采用了方法二，且没有建立新循环，而是在原来循环的基础上直接修改的，减少了空间复杂度。注意，该方法的核心为 `index <= i`，使得后面的不会被覆盖。

```cpp
int remove(int n, int arr[], int val){
    int index = 0;
    for(int i = 0; i < n; i++){
        if(arr[i]! = val){
            arr[index] = arr[i];
            index++;
        }
    }
    return index;
}
```

#### 3. 合并有序序列

**题目要求**：合并两个按**非递减**顺序排序的数组nums1和nums2，元素数量为m和n，合并后同样非递减。nums1数组长度为m+n，前m个元素表示应合并的元素。

- **方法一**：先拼接再排序；
- **方法二**：依次两个数组中符合条件的数弄到新数组。

**提升**：不允许新建空间

如果直接赋值到其中一个数组，会导致数据覆盖，利用从后往前可以做到不覆盖，实现代码如下：

```cpp
void merge(int nums1[], int m, int nums2[], int n){
    int p = m-- + (--n); // p = m+n-1; m = m-1; n = n-1;
    while(m>=0&&n>=0){
        nums1[p--] = nums1[m]>nums2[n]?nums1[m--]:nums2[n--];
    }
    while(n>=0){
        nums1[p--] = nums2[n--];
    }
}
```

**思考**：是否需要判断 `m>=0` 呢？

不用判断，因为是在第一个数组上直接操作的，如果 `m>=0` 此时数组1已经排序。下面的解法只处理 `nums2[]`，两个循环简化为一个循环。

```cpp
void merge(int nums1[], int m, int nums2[], int n){
    int p = m-- + (--n); // p = m+n-1; m = m-1; n = n-1;
    while(n>=0){
        nums1[p--] = m >= 0 && nums1[m]>nums2[n]?nums1[m--]:nums2[n--];
        // m < 0 时，总是执行 nums1[p--] = nums2[n--];
    }
}
```

### 空间换时间

动态规划问题是此类问题的典型。

#### 1. 爬楼梯

需要n阶到达楼顶，每次爬1或2个台阶，有多少种不同的爬法？

可以用斐波那契数列解决，$f(n) = f(n-1) + f(n-2)$，递归存在重复计算问题，动态规划即是用数组提速，实现代码如下：

```c++
#include<iostream>
using namespace std;
long long ret[100] = {0, 1, 2};
long long fib(int n){
    if(n && !ret[n]){ // 如果 ret[n] = 0 才会计算
        ret[n] = fib(n-1) + fib(n-2); 
    }
    return ret[n];
}
int main(){
    int n;
    cin >> n;
    long long num = fib(n);
    cout << num << endl;
    return 0;
}
```

全局变量生命周期贯穿程序运行，可以在任意位置使用，可能会造成程序混乱，不建议使用，下面代码采用 `static` 关键字，作用域在局部，但生命周期与全局变量相同，初始化操作只会执行一次。

```c++
long long fib(int n){
    static long long ret[100] = {0, 1, 2};
    if(n && !ret[n]){ // 如果 ret[n] = 0 才会计算
        ret[n] = fib(n-1) + fib(n-2); 
    }
    return ret[n];
}
```

### 打表法

打表法一般使用空间大小为 $10^6$，且要放在堆中，栈中放不下。

#### 1. 求差为1的整数对

下面是该问题解法的核心语句。

```cpp
...
if(cnt[i]&&cnt[i-1]){
    ans++;
}
...
```

下面是该问题解法核心语句的变种，较为巧妙。

```cpp
...
if(!(cnt[i] + cnt[i+1] -2)){
    ans++;
}
...
```

下面语句使用 `&`，是位运算，效率最高。

```cpp
...
if(cnt[i]&cnt[i-1]){
    ans++;
}
...
```

#### 2. 求数据之和

**题目要求**：第一行数据的个数N，第二行 N 个整数，第三行之后每行输入 i 和 j，输出其之间的元素和。

求和范围可能有重叠，重叠部分可能会超时，使用打表法解决，先计算 `table[i]` 为从 0 到 i 的值之和，之后返回 `table[i] - table[j]`，即为结果。

下面的解法用了**边界法**，因为要访问 i-1，因此把 `table[0]` 空出来，从 `table[1]` 开始存。

```cpp
#include<iostream>
using namespace std;
int main(){
    int n, x;
    cin >> n;
    int table[10010] = {0};
    for(int i = 0; i < n; ++i){
        cin >> x;
        table[i + 1] = table[i] + x; // 从 table[1] 开始存
    }
    int i, j;
    while(cin >> i >> j){
        cout << table[j] - table[i-1] << endl;
    }
    return 0;
}
```

### 排序

#### 1. 冒泡排序

每轮一个元素到对应位置，共 $n$ 轮，每轮比较 $i$ 次，$i = n-1, n-2, n-3 ,..., 1$，共 $\frac{n(n-1)}{2}$ 次，时间复杂度 $O(n^2)$。

#### 2. 选择排序

每次不交换，只记录下标，每轮把该下标元素与目标位置交换。

#### 3. 插入排序

#### 4. 快速排序

C++ 中提供的默认排序算法 `sort` 函数。

```cpp{10,11,12}
#include<iostream>
#include<algorithm>
using namespace std;
bool cmp(int a, int b){
    return a>b;
}

int main(){
    ...
    sort(a, a+n); // 升序
    reverse(a, a+n); // 降序
    sort(a, a+n, cmp); // 按照cmp规则排序，此为降序
    ...
    return 0;
}
```


