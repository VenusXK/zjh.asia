# 2021年山东大学专硕真题分析

[[TOC]]

## 简答题

### 01 排序

> 写出冒泡排序、堆排序、归并排序的时间复杂度。并说明在关键字有序的前提下，使用上述三种的哪一种排序算法效率最高，并写出效率最高的算法实现过程。


下面三种排序方法都是线性的。

- **冒泡排序**：比较两个，交换两个；
- **选择排序**：是记住位置，只交换一次位置；
- **插入排序**：是前面有序后面无序，依次处理交界面的元素。

| 排序方法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|:---:|
| 冒泡排序 | $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(1)$ | 稳定
| 选择排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定
| 插入排序 | $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(1)$ | 稳定

下面排序方法是基于分治策略

- **归并排序**：从小往大排序；
  - time_1：[49 38] [65 97] [76 13] [27]；
  - time_2：[38 49 65 97] [13 27 76]；
  - time_3：[13 27 38 49 65 76 97]；
- **快速排序**：从大往小排序；

快速排序流程如下：

| Origin | 49 | 38 | 65 | 97 | 76 | 13 | 27
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
time_1 | $i$ | 38 | 65 | 97 | 76 | 13 | 27 $j$
|  | 27 $i$ | 38 | 65 | 97 | 76 | 13 | $j$
time_2 | 27 | 38 | 65 $i$ | 97 | 76 | 13 | $j$
|  | 27 | 38 | $i$ | 97 | 76 | 13 | 65 $j$
time_3 | 27 | 38 | $i$ | 97 | 76 | 13 $j$ | 65
|  | 27 | 38 | 13 $i$ | 97 | 76 | $j$ | 65
time_4 | 27 | 38 | 13 | 97 $i$ | 76 | $j$ | 65
|  | 27 | 38 | 13 | $i$ | 76 | 97 $j$ | 65
time_5 | 27 | 38 | 13 | 49($i$, $j$) | 76 | 97 | 65


基于分治策略的排序算法对比如下：

| 排序方法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|:---:|
| 归并排序 | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(n)$ | 稳定
| 快速排序 | $O(n\log_2n)$ | $O(n^2)$ | $O(n\log_2n)$ | $O(n\log_2n)$ | 不稳定

堆排序和希尔排序是两种特殊的排序方法

| 排序方法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|:---:|
| 堆排序 | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(1)$ | 不稳定
| 希尔排序 | $O(n^{1.3})$ | $O(n^2)$ | $O(n)$ | $O(1)$ | 不稳定



## 算法题

### 02 二叉树遍历

> 写出基于链栈实现二叉树的中序遍历非递归算法，简述算法思想并给出时间复杂度和空间复杂度。

二叉树中序遍历非递归算法如下：

```cpp
void InOrder2(BiTree T){
    InitStack(S);
    BiTree p = T;
    while(p||!IsEmpty(S)){
        if(p){
            Push(S, p);
            p = p -> lchild;
        }
        else{
            Pop(S, p);visit(p);
            p = p -> rchild;
        }
    }
}
```

二叉树先序遍历非递归算法如下：

```cpp
void PreOrder2(BiTree T){
    InitStack(S);
    BiTree p = T;
    while(p||!IsEmpty(S)){
        if(p){
            visit(p);Push(S, p);
            p = p -> lchild;
        }
        else{
            Pop(S, p);
            p = p -> rchild;
        }
    }
}
```
