# 2024年山大预测3分析

[[TOC]]

## 简答题

### 02 完全二叉树叶结点数的一个特殊情况

> 如果一棵完全二叉树的叶结点数为 $2^{k-1}$，试问其深度一定为 k 吗？

不一定，可能为 k+1，其最下层只有最左边一个叶结点。

对一些二叉树的结论有些生疏，整理如下：

- 非空二叉树第 $k$ 层最多 $2^{k-1}$ 个结点
- 高为 $k$ 的二叉树最多有 $2^k-1$ 个结点，证明使用等比数列求和，等比数列求和公式：$S_n = \frac{a_1(1-q^n)}{1-q}$

一些关于完全二叉树的结论：

- 完全二叉树双亲结点编号为 $\lfloor i/2 \rfloor$
- 完全二叉树中，$2i\leq n$，结点 $i$ 的左孩子结点编号为 $2i$，否则无左孩子
- 完全二叉树中，$2i+1\leq n$，结点 $i$ 的右孩子结点编号为 $2i+1$，否则无右孩子
- 完全二叉树中，结点 $i$ 所在二叉树深度为 $\lfloor \log_2 i \rfloor + 1$
- $n$ 个结点的完全二叉树的深度为 $\lfloor \log_2 n \rfloor + 1$ 或 $\lceil \log_2 (n+1) \rceil$。

::: warning $\lfloor \log_2 n \rfloor + 1$ 和 $\lceil \log_2 (n+1) \rceil$ 结论的形象化描述

形象化理解如下，该结点在s和m之间，取不到s，因此大于`上一层满二叉树的结点数`，小于等于`最底层满二叉树的结点数`，所以深度为 $\lceil \log_2 (n+1) \rceil$。

```
    /  \ 
   /\  /\
         s
  /\/\/\/\
          m
```


同理，根据下面的形象化描述，该结点在s和m之间，取不到m，因此大于等于`上一层满二叉树的结点数+1`，小于`最底层满二叉树的结点数+1`，所以深度为 $\lceil \log_2 (n+1) \rceil$。

```
    /  \ 
   /\  /\
  /\/\/\/\
  s        
 /
 m
```
:::

### 02 三阶B-树的删除

> 设一3阶B-树如下所示，写出删除关键字 11，49，52，36 后的B-树结构。
>
> ```
>          | 44 |
>         /      \
>     |43|      | 52 89 |
>   /     \     /   \    \
> |2 11||36| |49||60 69||99|
> ```


前面删除都比较容易，但是在删除36时有点小坑，注意兄弟不够借的时候，**把被删除结点(包括其携带的指针)和父结点的关键字都移到兄弟结点**，此时移动的父结点之前所在的结点并没有删除，而是可能变为空结点，使其不符合B-树的定义，需要重复调整。

《王道》描述如下：

- 若双亲结点是根结点，关键字字数减少到 $0$，则其只有一棵子树，直接删除该结点，子树结点作为新的根结点
- 若双亲结点不是根结点，关键字字数减少到 $\lceil m/2 \rceil -2$，则又要与其兄弟结点进行调整或合并操作，直到符合B树要求为止

删除36之前的B-树如下：

```
         |44|
        /      \
    |43|     | 89 |
    /  \     /    \
  |2| |36| |60 69||99| 
```

删除36后，B-树如下

```
         |44|
        /      \
    |  |     | 89 |
    /        /    \
  |2 43|  |60 69||99| 
```

`|2 43|` 父结点发生下溢，向右侧兄弟 `|89|` 借一个结点，不够借，父结点下移，如下：

```
      |  |（44之前在的结点）
        |   
    |  44 89  |
    /    \    \
  |2 43| |60 69||99| 
```

双亲结点是根结点，关键字字数减少到 $0$，则其只有一棵子树，直接删除该结点，子树结点作为新的根结点，如下：

```
    |  44 89  |
    /    \    \
  |2 43| |60 69||99| 
```

### 05 逻辑结构和物理(存储)结构

> 堆用数组作为存储结构，那么它是线性结构还是非线性结构？堆与二叉搜索树有什么区别？

- **逻辑结构**：（线性结构）线性表、栈、队列；（非线性结构）集合、树、图
- **存储结构**：顺序、链式、索引、散列

堆用数组作为存储结构，是顺序结构，同时是树，是非线性结构。

- 二叉查找树是为了实现动态查找而设计的数据结构，它是面向查找操作的，在二叉排序树中查找一个结点的平均时间复杂度是 $O(\log_2n)$，为了解决二叉查找树退化为单链表时查找效率低下的问题，引入了平衡二叉树(AVL)
- 堆是为了实现排序而设计的一种数据结构，它不是面向查找操作的。堆的查找、插入、删除都稳定在 $O(\log_2n)$，因为堆是一棵完全树，不会退化为单链表

## 程序设计题

### 01 直接插入排序代码

> 设计算法对于公式化描述的线性表，设计基于公式的类LinearList的一个成员函数insertionsortlist()，实现直接插入排序算法，并分析时间复杂度。

公式化描述指的是用数组存储的线性表。

答案在解这类程序设计题目时，总是先给出数据结构，再给出算法，因此需要记住常用的数据结构和算法。

直接插入排序为前面有序，中间为待排序元素，后方为无序元素，每次取中间的无序元素插入到前面有序元素中，答案给出的代码比较巧妙，如下：

```cpp
template <class T>
Class LinearList{
public:
    LinearList(int MaxListSize = 10);
    ~LinearList(){delete [] element;}
    void insertionsortlist();
private:
    int MaxSize;
    int length;
    T *element;
};


void Insert(int a[], int n, int x){
    for(int i = n-1; i>=0 && x<a[i]; i--)
        a[i+1] = a[i];
    a[i+1] = x;
}

void insertionsortlist(int a[], int n){
    for(int i = 1; i < n; i++){
        int x = a[i];
        Insert(a, i, x);
    }
}
```

### 02 有向图邻接表增加弧

> 已知有向图以邻接表方式存储，设计算法在图中增加一条弧(i, j)。

答案给的解法为用数组存储头结点结构体，遍历边表节点时，使用两个指针进行试探，若其中一个为空，则创造指针并连接即可。

```cpp
typedef struct ArcNode{
    int adjvex;
    struct ArcNode *nextarc;
    int info;
}
typedef struct VNode{
    int data;
    ArcNode *firstarc;
}VNode;
typedef struct AGraph{
    VNode adjlist[MAXVEX];
    int n, e;
}AGraph;
void InsertArc(AGraph *G, int i, int j){
    ArcNode *p, *q;
    p = G->adjlist[i].firstarc;
    while(p && p->adjvex != j)
        p = p->nextarc;
    if(!p){
        q = (ArcNode *)malloc(sizeof(ArcNode));
        q->adjvex = j;
        q->nextarc = G->adjlist[i].firstarc;
        G->adjlist[i].firstarc = q;
        G->e++;
    }
    else{
        printf("The arc has existed!\n");
        return;
    }
}
```