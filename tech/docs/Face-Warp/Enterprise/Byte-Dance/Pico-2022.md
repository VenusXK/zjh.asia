# 2022 年春 PICO 青岛面经 1

https://blog.csdn.net/weixin_43735161/article/details/123669048?spm=1001.2014.3001.5502

> 去年（2021年）12月，考研前几天，导员儿在群里发了字节的实习。投了一下，一直没消息，以为凉了，没想到二月底给我打电话让我约面试…因为在同时准备毕设和复试，就一直没有约面试。无奈HR一直催，说在春招要快一些。于是约了3月14日的一面。

如果年末投递日常实习，HR发面试消息要在年后，而且面试之前有一段时间可以补面经。

```
// 一面
自我介绍
之前用什么开发语言（很重要 你说什么他就会着重问你什么语言）
C程序从编译到运行的过程说一下
浅拷贝深拷贝的区别
虚基类与析构函数相关
什么是多态
静态变量有什么作用
数组和指针的区别
指针和引用有什么区别
存储空间分为哪些部分？（栈、堆、全局区、字符常量区、程序代码区）
进程、线程的区别
进程间通信方式
死锁是什么意思？怎么预防？
安卓了解吗（我说不了解，然后没往下问）
人脸识别实现（简历上项目相关）
你打的ACM是什么形式，几个人参赛
你还有什么问题（幸好提前做了功课，问了下他们产品业务实现方面的问题）
代码题：中序遍历二叉树

// 二面
〇、简历相关
	0、自我介绍
	1、讲一下你的项目中的人脸识别程序
	2、平常用什么开发语言（我说c++比较多
一、c++
	3、c++ STL库中vector和list区别
	4、c++ 结构体与类的区别（我没答上来 面试官提示说类内权限 我就回答类默认私有 结构体默认公有）
	5、多态是什么 怎么实现 需要基类的函数前面加什么？
	6、静态成员是什么
	7、静态函数能否访问普通成员变量
二、数据结构
	8、举几个排序算法的例子 说一下他们的空间时间复杂度
三、计算机组成原理
	9、说一下浮点数的格式
	10、ASCII和Unicode有什么区别（后者兼容前者）
	11、UTF-8中文字符和英文字符占几个字节？
	12、什么是内存对齐？
	13、假如一个结构体有int char float 说一下它对齐的方式
	14、内存空间分为几个区 举这几个区的例子
	15、成员函数里定义的静态成员存储在哪个区
四、计算机操作系统
	16、死锁是什么
	17、线程与进程的区别
	18、线程之间如何进行通信
	19、线程之间如何实现同步
	20、线程之间的空间都是可以共享的吗（存在栈里的不行，全局、堆里的不行）
五、计算机网络
	21、计算机网络的四层结构（五层也行
	22、说一下每层都有什么协议
	23、路由器工作在什么层
六、算法题
	24、全排列
	25、链表倒数第k个元素
七、其他
	26、你参加的竞赛是什么形式 你和队友在解题过程中遇到不会的题怎么办？
	27、你还有什么问题？
	28、你的职业规划？（回答进大厂）
```

## C程序从编译到运行的过程说一下

C 源文件 -> **预处理**：生成预处理后的C源文件 `hello.i`，删除所有的注释、宏扩展、头文件包含 -> **编译**：将C源文件翻译成汇编文件 `hello.s` -> **汇编**：将汇编文件汇编成目标文件 `hello.o`(二进制/十六进制形式) -> **链接**：将目标文件链接成可执行文件，将库文件包含在程序中。

## 浅拷贝深拷贝的区别

深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。

**浅拷贝**：浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝；如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

**深拷贝**：深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”（不是分支）；

::: info 举例
函数传参传递值是深拷贝，引用传参是浅拷贝；
:::

在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数，即浅拷贝，它能够完成成员的复制。

**浅拷贝代码实例**：

```c++ 
class A {
    public:
        A(int _data):data(_data){}
        A();
    private:
        int data;
}

int main(){
    A a(5);
    A b=a;//仅仅是数据成员之间的赋值
}
```

**当数据成员中没有指针时，浅拷贝是可行的**，**但当数据成员中有指针时**，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，从而导致指针悬挂现象，所以，此时，**必须采用深拷贝**。

深拷贝就是指当拷贝的对象中有对其他资源（如堆、文件、系统等）的引用时，对象另外开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。

**错误的拷贝代码实例**：

```c++
class A {
    public:
        A(int _size):size(_size){
            data = new int[size];
        }
        A();
        ~A(){ //析构时释放资源
            delete []data;
        }
    private:
        int *data;
        int size;
}

int main(){
    A a(5);
    A b=a;
    // 这里的 `b=a` 会造成未定义行为，因为类A中的 `copy` 构造函数是编译器生成的，所以 `b = a` 执行的是一个浅拷贝的过程。
}
```

这里 `b` 的指针和 `a` 的指针指向了堆上的同一块内存，`a` 和 `b` 析构时，`b` 先把 `data` 执行的分配的内存释放了一次，而后 `a` 析构时又将这块已经被释放的内存再释放一次，对同一块内存执行2次以上释放的结果是未定义的，所以这会导致内存泄漏或程序崩溃。

**正确使用深拷贝的代码实例**

```cpp
class A{
    public:
        A(int _size):size(_size){
            data = new int[size];
        }
        A();
        A(const A &_A):size(_A.size){ // 深拷贝
            data = new int[size];
        }
        ~A(){
            delete []data;
        }
    private:
        int *data;
        int size;
}

int main(){
    A a(5),b=a;
}
```

深拷贝和浅拷贝的区别就在于**深拷贝会在堆内存中另外申请空间来存储数据**，从而也就解决了指针悬挂的问题。当**数据成员中有指针**时，**必须要用深拷贝**。

## 什么是多态

https://blog.csdn.net/m0_72940975/article/details/132315276

多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。

**在继承中要构成多态还有两个条件**：1) 必须通过基类的指针或者引用调用虚函数；2) 被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。

### 虚函数的重写

派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数，实例如下：

```cpp
class Person {
public:
    virtual void BuyTicket() { cout << "买票-全价" << endl; }
};
 
class Student : public Person {
public:
    virtual void BuyTicket() { cout << "买票-半价" << endl; }
};
```

虚函数重写有两个例外，如下所述：

**协变**：派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用时，称为协变，协变实例：

```cpp
class A{};
class B : public A {};
 
class Person {
public:
    virtual A* f() {return new A;}
};
 
class Student : public Person {
public:
    virtual B* f() {return new B;}
};
```

**析构函数的重写**：如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加 `virtual` 关键字，都与基类的析构函数构成重写。

虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成 `destructor`。

```cpp
class Person {
public:
    virtual ~Person() {cout << "~Person()" << endl;}
};
class Student : public Person {
public:
    virtual ~Student() { cout << "~Student()" << endl; }
};

int main()
{
    Person* p1 = new Person;
    Person* p2 = new Student;
 
    delete p1;
    delete p2;
 
    return 0;
}
```

只有派生类 `Student` 的析构函数重写了 `Person` 的析构函数，下面的 `delete` 对象调用析构函数，才能构成多态，才能保证 `p1` 和 `p2` 指向的对象正确的调用析构函数。

### 虚函数关键字

C++11 为虚函数提供了关键字 `override` 和 `ﬁnal`。

`override`: 检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。

```cpp
class Car{
public:
    virtual void Drive(){}
};
 
class Benz :public Car {
public:
    virtual void Drive() override {cout << "Benz-舒适" << endl;}
};
```

`ﬁnal`：修饰虚函数，表示该虚函数不能再被继承

```cpp
class Car{
    public:
        virtual void Drive() final {}
};

class Benz :public Car{
    public:
        virtual void Drive() {cout << "Benz-舒适" << endl;}
};
```

### 抽象类

在虚函数的后面写上 `=0`，则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类，抽象类不能实例化出对象。

派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，纯虚函数更体现出了接口继承。

**接口和抽象类的区别**：接口表示对外提供的方法，提供给外部调用。一般接口类只具有成员函数，不具有数据成员；抽象类可以既包含数据成员又包含方法。

```cpp
class IShape{
    public:
        virtual float getArea()=0; //纯虚函数，获得面积
        virtual string getName()=0; //纯虚函数，返回图形的名称
};
```

**接口继承和实现继承**：普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数。

## 静态变量有什么作用

内容来自：https://c.biancheng.net/view/301.html

### 隐藏与隔离的作用

静态变量的存储方式与全局变量一样，都是静态存储方式。但这里需要特别说明的是，静态变量属于静态存储方式，属于静态存储方式的变量却不一定就是静态变量。例如，全局变量虽然属于静态存储方式，但并不是静态变量，它必须由 `static` 加以定义后才能成为静态全局变量。

全局变量虽然属于静态存储方式，但并不是静态变量。全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，全局变量在各个源文件中都是有效的。

如果我们希望全局变量仅限于在本源文件中使用，在其他源文件中不能引用，也就是说限制其作用域只在定义该变量的源文件内有效，而在同一源程序的其他源文件中不能使用。这时，就可以通过在全局变量之前加上关键字 `static` 来实现，使全局变量被定义成为一个静态全局变量。这样就可以避免在其他源文件中引起的错误。也就起到了对其他源文件进行隐藏与隔离错误的作用，有利于模块化程序设计。

### 保持变量内容的持久性

有时候，我们希望函数中局部变量的值在函数调用结束之后不会消失，而仍然保留其原值。即它所占用的存储单元不释放，在下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值。这时候，我们就应该将该局部变量用关键字 `static` 声明为“静态局部变量”。

当将局部变量声明为静态局部变量的时候，也就改变了局部变量的存储位置，即从原来的栈中存放改为静态存储区存放。这让它看起来很像全局变量，其实**静态局部变量与全局变量的主要区别就在于可见性**，静态局部变量只在其被声明的代码块中是可见的。

对某些必须在调用之间保持局部变量的值的子程序而言，静态局部变量是特别重要的。如果没有静态局部变量，则必须在这类函数中使用全局变量，由此也就打开了引入副作用的大门。

使用静态局部变量最好的示例就是实现统计次数的功能，如下面示例所示。

```cpp
#include <stdio.h>
void count();
int main(void)
{
    int i=0;
    for (i = 0;i <= 5;i++)
    {
            count();
    }
    return 0;
}
void count()
{
    /*声明一个静态局部变量*/
    static num = 0;
    num++;
    printf("%d\n",num);
}
```

在该代码中，我们通过在 `count()` 函数里声明一个静态局部变量 `num` 来作为计数器。因为**静态局部变量是在编译时赋初值**的，且只赋初值一次，在程序运行时它已有初值。以后在每次调用函数时就不再重新赋初值，而是保留上次函数调用结束时的值。这样，`count()` 函数每次被调用的时候，静态局部变量 `num` 就会保持上一次调用的值，然后再执行自增运算，这样就实现了计数功能。同时，它又避免了使用全局变量。

通过上面的示例，我们可以得出静态局部变量一般的使用场景，如下所示：

- 需要保留函数上一次调用结束时的值。
- 如果初始化后，变量只会被引用而不会改变其值，则这时用静态局部变量比较方便，以免每次调用时重新赋值。

## 数组和指针的区别

https://blog.csdn.net/cherrydreamsover/article/details/81741459

**数组**：数组是用于储存多个相同类型数据的集合。

**指针**：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。

---

**存储方式**

数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。

指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。

---

**变量的大小不同**

数组所占存储空间的内存：`sizeof（数组名）`，数组的大小：`sizeof（数组名）/sizeof（数据类型）`

在 32 位平台下，无论指针的类型是什么，`sizeof（指针名）`都是 4，在 64 位平台下，无论指针的类型是什么，`sizeof（指针名）` 都是 8。

## 指针和引用有什么区别

https://blog.csdn.net/xsydalao/article/details/93623647

指针和引用都是地址的概念，指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。

**内存方面**：程序为指针变量分配内存区域，而不为引用分配内存区域。

**不同的指向**：对引用使用 `sizeof` 得到的是变量的大小，对指针使用 `sizeof` 得到的是变量的地址的大小；就 `++` 操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。

**即引用的对象不能改变，指针的对象可以改变**：引用在定义时就被初始化，之后无法改变；指针可以发生改变。 

**没有空引用，但有空指针**：这使得使用引用的代码效率比使用指针的更高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。

**使用级数**：理论上指针的级数没有限制，但引用只有一级。即不存在引用的引用，但可以有指针的指针。

```cpp
int **p //合法
int &&p //非法
```

## 栈、堆、全局区、字符常量区、程序代码区

https://blog.csdn.net/u014470361/article/details/79297601

<u>高地址 <- 栈区(向下增长) - 堆区(向上增长) - 静态区(全局区) - 常量区 - 代码区 -> 低地址</u>


**代码区**：存放程序的代码，即CPU执行的机器指令，并且是只读的；

**常量区**：存放常量(程序在运行的期间不能够被改变的量，例如: 10，字符串常量”abcde”， 数组的名字等)；

**静态区（全局区）**：静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配, 静态区的内存直到程序全部结束之后才会被释放；

**堆区**：由程序员调用malloc()函数来主动申请的，需使用free()函数来释放内存，若申请了堆区内存，之后忘记释放内存，很容易造成内存泄漏；

**栈区**：存放函数内的局部变量，形参和函数返回值。栈区之中的数据的作用范围过了之后，系统就会回收自动管理栈区的内存(分配内存 , 回收内存),不需要开发人员来手动管理。栈区就像是一家客栈，里面有很多房间，客人来了之后自动分配房间，房间里的客人可以变动，是一种动态的数据变动。



## 进程、线程的区别

https://blog.csdn.net/ThinkWon/article/details/102021274

**进程**：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程；

**线程**：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。

---

与进程不同的是同类的**多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

---

**根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

**资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

**内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

**影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

**执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

## 进程间通信方式
