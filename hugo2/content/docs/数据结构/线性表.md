---
title: 线性表 C++ 代码复习
description: 描述
summary: 机械工业出版社《数据结构、算法与应用》线性表代码默写
date: "2023-10-01"
categories:
  - 数据结构
tags:
  - C++
  - 线性结构
---

- [linearList 的抽象类定义](#linearlist-的抽象类定义)
- [三种映射关系](#三种映射关系)
- [变长一维数组](#变长一维数组)
- [类 arrayList 定义](#类-arraylist-定义)
- [类 arrayList 构造函数](#类-arraylist-构造函数)
- [类 arrayList 复制函数](#类-arraylist-复制函数)
- [类 arrayList 实例化](#类-arraylist-实例化)
- [checkIndex()](#checkindex)


### linearList 的抽象类定义

```
// 抽象数据类型
template<class T>
class linearList{
    public:
          virtual ~LinearList() {};

          // group1
          virtual bool empty() const = 0; // `=0` 则变为纯虚函数，基类只做能被继承，而不能被实例化；这个方法必须在派生类中被实现；
          virtual int size() const = 0; // `const` 使类的成员函数不能被修改
          
          // group2
          virtual T& get(int theIndex) const;
          virtual int indexOf(const T& theElement) const = 0; // `const` 修饰可以防止函数内意外修改该参数，起到保护作用。
          
          // group3
          virtual void insert(int theIndex, const T& theElement)= 0;
          virtual void erase(int theIndex) = 0;
          
          
          virtual void output(ostream& out) const = 0;
}
```

### 三种映射关系

```
location(i) = i；
location(i) = arrayLength - i - 1;
location(i) = (location(0) + i) % arrayLength； 
```

### 变长一维数组

```
template<class T>
void changeLength1D(T*& a, int oldLength, int newLength){
    if(newLength < 0)
        throw illegalParameterValue("new length must be >= 0");

    T * arr = new T[newLength];
    int newLength = min(oldLength, newLength);
    copy(a, a + newLength, arr);
    delete [] a;
    a = arr;
}
```



### 类 arrayList 定义 

> 一些关于模板类继承的知识：[https://zhuanlan.zhihu.com/p/426518132](https://zhuanlan.zhihu.com/p/426518132)

```
template<class T>
class arrayList : public linearList<T>{ //模板类继承模板类
    public:
        void ~arrayList();
        bool empty();
        int size();
        int indexOf(T& theElement);
        T& get(int theIndex);
        void insert(T& theElement, int theIndex);
        void erase(int theIndex);
        void output();
    protected:
        int maxSize;
        int currentSize;
        T& element;
}
```

修改:

```
template<class T>
class arrayList : public linearList<T>{ //模板类继承模板类
    public:
        arrayList(int initialCapacity = 10);
        arrayList(const arrayList<T>&);
        ~arrayList(){
          delete [] element;
        }
        
        bool empty() const {return listSize == 0};
        int size() const {return listSize};
        int indexOf(const T& theElement) const;
        T& get(int theIndex) const;
        void insert(const T& theElement, int theIndex);
        void erase(int theIndex);
        void output(ostrean& out) const;

        int capacity() const {
          return arrayLength;
        }
    protected:
        void checkIndex(int theIndex) const;
        int arrayLength;
        int listSize;
        T* element;
}
```

### 类 arrayList 构造函数

```
template<class T>
void arrayList<T>::arrayList(int initalCapacity){
    arrayLength = initalCapacity;
    element = new T[arrayLength];
    listSize = 0;
}
```

修改：

```
template<class T>
arrayList<T>::arrayList(int initalCapacity){ // 没有返回值
    if(initalCapacity < 1){
      ostringstream s;
      s << "Initial capacity = " << initalCapacity << "Must be > 0";
      throw illegalParameterValue(s.str());
    }
    arrayLength = initalCapacity;
    element = new T[arrayLength];
    listSize = 0;
}
```

### 类 arrayList 复制函数

> 效果不好，需复习

```
template<class T>
arrayList<T>::arrayList(const arrayList<T>& theList){
    listSize = theList.listSize;
    arrayLength = theList.arrayLength;
    element = new[arrayLength];
    copy(theList.element, theList.element + listSize, element);
}
```

### 类 arrayList 实例化

```
linearList * l = (linearList) new arrayList<int>(100);
arrayList<int> y(100);
arrayList<int> y;
arrayList<int> w(y);
```

### checkIndex()